#include <cassert>
#include "ParetoMode.hpp"

#include "../utils/utils.hpp"

#include "../arguments/measureSelector.hpp"
#include "../arguments/methodSelector.hpp"
#include "../arguments/graphLoader.hpp"

#include "../report.hpp"
#include <iostream>

void ParetoMode::run(ArgumentParser& args) {
    createFolders();
    Graph G1, G2;
    initGraphs(G1, G2, args);

    setArgsForParetoMode(args);
    MeasureCombination M;
    initMeasures(M, G1, G2, args);
    Method* method;
    method = initMethod(G1, G2, args, M);
    //Alignment A = method->runAndPrintTime();
    vector<Alignment> *B = runParetoMode(method, &G1, &G2);
    Alignment A = Alignment((*B)[0]);
    //Alignment A = method->run();

    A.printDefinitionErrors(G1,G2);
    assert(A.isCorrectlyDefined(G1, G2) and "Resulting alignment is not correctly defined");

    saveReport(G1, G2, A, M, method, args.strings["-o"]);
    saveLocalMeasures(G1, G2, A, M, method, args.strings["-localScoresFile"]);
    delete method;
}

string ParetoMode::getName(void) {
    return "ParetoMode";
}


void ParetoMode::createFolders(void) {
    createFolder("matrices");
    createFolder("matrices/autogenerated");
    createFolder("tmp");
    createFolder("alignments");
    createFolder("go");
    createFolder("go/autogenerated");
}

void ParetoMode::setArgsForParetoMode(ArgumentParser& args) {
    args.doubles["-ec"] = args.doubles["-s3"] = args.doubles["-tc"] = args.doubles["-sec"]
                        = args.doubles["-wec"] /*= args.doubles["-nodec"]*/ = args.doubles["local"]//= args.doubles["-noded"]
                        //= args.doubles["-edgec"] /*= args.doubles["-edged"]*/ = args.doubles["-go"]
                        //= args.doubles["-importance"] = args.doubles["-sequence"] = args.doubles["-graphlet"]
                        //= args.doubles["-graphletlgraal"] = args.doubles["-graphletcosine"] /*= args.doubles["-spc"]*/
                        = args.doubles["-nc"] = args.doubles["-mec"] /*= args.doubles["-ewec"]*/ = args.doubles["-ses"]
                        = 1;

    args.strings["-combinedScoreAs"] = "pareto";
    args.strings["-method"] = "sana";
}

vector<Alignment>* ParetoMode::runParetoMode(Method *method, Graph *G1, Graph *G2) {
    cout << "Start execution of " << method->getName() << " in Pareto Mode." << endl;
    Timer T;
    T.start();
    //Method* METHOD = new SANA;
    //static_cast<SANA*>(METHOD)->derived_int;
    //unordered_set<vector<unsigned short>*> *A = static_cast<SANA*>(method)->paretoRun();
    //A->push_back(method->paretoRun());
    T.elapsed();
    cout << "Executed " << method->getName() << " in " << T.elapsedString() << endl;

    // Re Index back to normal (Method #3 of locking)

    // Needs to be reimplemented with unordered_set<vector<unsigned short>>*
    
    /*if(G1->hasNodeTypes()){
        G1->reIndexGraph(method->getReverseMap(G1->getNodeTypes_ReIndexMap()));
        (*A)[0].reIndexAfter_Iterations(G1->getNodeTypes_ReIndexMap());
    }
    // if locking is enabled but hasnodeType is not
    else if(G1->getLockedCount() > 0){
         G1->reIndexGraph(method->getReverseMap(G1->getLocking_ReIndexMap()));
          (*A)[0].reIndexAfter_Iterations(G1->getLocking_ReIndexMap());
    }
    method->checkLockingBeforeReport((*A)[0]);
    method->checkLockingBeforeReport((*A)[0]);*/
    return new vector<Alignment>;
}
    